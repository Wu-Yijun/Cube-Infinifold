name: Build Only

on:
  workflow_dispatch:
  push:

env:
  EXECUTABLE_NAME: cube-infinifold
  EXECUTABLE_CHECK_NAME: cube-infinifold-check
  ENABLE_CARGO_TEST: 'false'
  ENABLE_CARGO_BUILD: 'false'
  ENABLE_PROGRAM_CHECK: 'false'


  BUILD_ON_UBUNTU: 'true'
  BUILD_ON_WINDOWS: 'false'
  BUILD_ON_MAC: 'false'

jobs:
  prepare:
    runs-on: ubuntu-latest
    steps:
      - name: Set outputs
        id: set_outputs
        run: |
          echo "BUILD_ON_UBUNTU=${BUILD_ON_UBUNTU}" >> $GITHUB_ENV
          echo "BUILD_ON_WINDOWS=${BUILD_ON_WINDOWS}" >> $GITHUB_ENV
          echo "BUILD_ON_MAC=${BUILD_ON_MAC}" >> $GITHUB_ENV
    outputs:
      BUILD_ON_UBUNTU: ${{ env.BUILD_ON_UBUNTU }}
      BUILD_ON_WINDOWS: ${{ env.BUILD_ON_WINDOWS }}
      BUILD_ON_MAC: ${{ env.BUILD_ON_MAC }}

  build_on_ubunutu:
    needs: prepare
    if: ${{ needs.prepare.outputs.BUILD_ON_UBUNTU == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: ubuntu:latest
    steps:
      - uses: actions/checkout@main
      # Set up ffmpeg environment
      - name: Install dependencies
        run: |
          sudo apt install -y --no-install-recommends clang curl pkg-config
          sudo apt install libavcodec-dev libavutil-dev libavformat-dev libavfilter-dev libavdevice-dev
      # Install rust toolchain
      - name: Install rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      # Set up Rust
      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      # Build the project
      - name: Build Project
        if: ${{ env.ENABLE_CARGO_BUILD == 'true' }}
        run: cargo build --verbose --release
      # Create binary file if not building
      - name: Create Binary
        if: ${{ env.ENABLE_CARGO_BUILD != 'true' }}
        run: |
          mkdir -p ./target/release
          touch ./target/release/${{ env.EXECUTABLE_NAME }}
          touch ./target/release/${{ env.EXECUTABLE_CHECK_NAME }}
          touch ./target/release/empty.so
      # List the files in the target/release directory
      - name: List Files
        run: |
          ls -R /usr/lib/*libav*
          echo "--- Hello World ---"
          dpkg -l | grep libavcodec
          echo "--- Hello World ---"
          ldd ffmpeg
          ls ./target/release
      # Run the tests
      - name: Cargo Test
        if: ${{ env.ENABLE_CARGO_TEST == 'true' }}
        run: cargo test
      # copy and compress the binary and library into a zip file
      - name: Copy and Compress Binary
        run: |
          cd ./target/release
          mkdir -p temp_files/libs
          mv ${{ env.EXECUTABLE_NAME }} temp_files/
          mv *.so temp_files/libs/
          cd temp_files
          zip -r ../${{ env.EXECUTABLE_NAME }}_ubuntu.zip .
          cd ..
          mv ${{ env.EXECUTABLE_CHECK_NAME }} temp_files/
          cd ..
          cd ..
      # Test the Rust program
      - name: Run Rust program
        if: ${{ env.ENABLE_PROGRAM_CHECK == 'true' }}
        run: |
          ./${{ env.EXECUTABLE_CHECK_NAME }}
          exit_code=$?
          if [ $exit_code -ne 0 ]; then
            echo "Rust program failed with exit code $exit_code"
            exit 1
          fi
        working-directory: ./target/release/temp_files
      # delete the temp_files directory
      - name: Delete temp_files
        run: |
          rm -rf ./target/release/temp_files
      # then upload the zip
      - name: Upload Asset
        uses: actions/upload-artifact@main
        with:
          name: ${{ env.EXECUTABLE_NAME }}_ubuntu
          path: ./target/release/${{ env.EXECUTABLE_NAME }}_ubuntu.zip
          compression-level: 0

  build_on_windows:
    needs: prepare
    if: ${{ needs.prepare.outputs.BUILD_ON_WINDOWS == 'true' }}
    runs-on: windows-latest
    container:
      image: windows:latest
      # image: mcr.microsoft.com/windows/servercore:ltsc2019
    steps:
      - uses: actions/checkout@main
      # Set up ffmpeg environment
      - name: Install dependencies
        run: |
          $VCINSTALLDIR = $(& "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe" -latest -property installationPath)
          Add-Content $env:GITHUB_ENV "LIBCLANG_PATH=${VCINSTALLDIR}\VC\Tools\LLVM\x64\bin`n"
          Invoke-WebRequest "${env:FFMPEG_DOWNLOAD_URL}" -OutFile ffmpeg-release-full-shared.7z
          7z x ffmpeg-release-full-shared.7z
          mkdir ffmpeg
          mv ffmpeg-*/* ffmpeg/
          Add-Content $env:GITHUB_ENV "FFMPEG_DIR=${pwd}\ffmpeg`n"
          Add-Content $env:GITHUB_PATH "${pwd}\ffmpeg\bin`n"
        env:
          FFMPEG_DOWNLOAD_URL: https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-full-shared.7z
      # Install rust toolchain
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      # Build the project
      - name: Build Project
        if: ${{ env.ENABLE_CARGO_BUILD == 'true' }}
        run: cargo build --release
      # Create binary file if not building
      - name: Create Binary
        if: ${{ env.ENABLE_CARGO_BUILD != 'true' }}
        run: |
          mkdir -p ./target/release
          echo . > ./target/release/${{ env.EXECUTABLE_NAME }}.exe
          echo . > ./target/release/${{ env.EXECUTABLE_CHECK_NAME }}.exe
      # Cargo Test
      - name: Cargo Test
        if: ${{ env.ENABLE_CARGO_TEST == 'true' }}
        run: cargo test
      # List the files in the target/release directory
      - name: List Files
        run: |
          cp ${pwd}/ffmpeg/bin/*.dll ./target/release
          ls ./target/release
      # copy and compress the binary and library into a zip file
      - name: Copy and Compress Binary
        run: |
          cd ./target/release
          mkdir -p ${{ env.EXECUTABLE_NAME }}_windows/libs
          mv ${{ env.EXECUTABLE_NAME }}.exe ${{ env.EXECUTABLE_NAME }}_windows/
          mv *.dll ${{ env.EXECUTABLE_NAME }}_windows/libs/
          Compress-Archive -Path "${{ env.EXECUTABLE_NAME }}_windows" ${{ env.EXECUTABLE_NAME }}_windows.zip
          mv ${{ env.EXECUTABLE_CHECK_NAME }}.exe ${{ env.EXECUTABLE_NAME }}_windows/
          cd ..
          cd ..
      # Test the Rust program
      - name: Run Rust program
        if: ${{ env.ENABLE_PROGRAM_CHECK == 'true' }}
        run: |
          ./${{ env.EXECUTABLE_CHECK_NAME }}.exe
          $exit_code = $LASTEXITCODE
          if ($exit_code -ne 0) {
            Write-Output "Rust program failed with exit code $exit_code"
            exit 1
          }
        working-directory: ./target/release/${{ env.EXECUTABLE_NAME }}_windows
      # delete the cube-infinifold_windows directory
      - name: Delete cube-infinifold_windows
        run: |
          Remove-Item -Path "./target/release/${{ env.EXECUTABLE_NAME }}_windows" -Recurse -Force
      # then upload the zip
      - name: Upload Asset
        uses: actions/upload-artifact@main
        with:
          name: ${{ env.EXECUTABLE_NAME }}_windows
          path: ./target/release/${{ env.EXECUTABLE_NAME }}_windows.zip
          compression-level: 0

  build_on_mac:
    needs: prepare
    if: ${{ needs.prepare.outputs.BUILD_ON_MAC == 'true' }}
    runs-on: macos-latest
    container:
      image: macos:latest
    steps:
      - uses: actions/checkout@main
      # Set up ffmpeg environment
      - name: Install dependencies
        run: brew install ffmpeg pkg-config
      # Install rust toolchain
      - name: Install rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      # Build the project
      - name: Build Project
        if: ${{ env.ENABLE_CARGO_BUILD == 'true' }}
        run: cargo build --verbose --release
      # Create binary file if not building
      - name: Create Binary
        if: ${{ env.ENABLE_CARGO_BUILD != 'true' }}
        run: |
          mkdir -p ./target/release
          touch ./target/release/${{ env.EXECUTABLE_NAME }}
          touch ./target/release/${{ env.EXECUTABLE_CHECK_NAME }}
      # Cargo Test
      - name: Cargo Test
        if: ${{ env.ENABLE_CARGO_TEST == 'true' }}
        run: cargo test
      # List the files in the target/release directory
      - name: List Files
        run: |
          ffmpeg_path=$(brew --prefix ffmpeg)
          cp $ffmpeg_path/lib/*.dylib ./target/release
          ls ./target/release
      # copy and compress the binary and library into a zip file
      - name: Copy and Compress Binary
        run: |
          cd ./target/release
          mkdir -p temp_files/libs
          cp ${{ env.EXECUTABLE_NAME }} temp_files/
          cp *.dylib temp_files/libs/
          cd temp_files
          zip -r ../${{ env.EXECUTABLE_NAME }}_macos.zip .
          cd ..
          mv ${{ env.EXECUTABLE_CHECK_NAME }} temp_files/
          cd ..
          cd ..
      # Test the Rust program
      - name: Run Rust program
        if: ${{ env.ENABLE_PROGRAM_CHECK == 'true' }}
        run: |
          ./${{ env.EXECUTABLE_CHECK_NAME }}
          exit_code=$?
          if [ $exit_code -ne 0 ]; then
            echo "Rust program failed with exit code $exit_code"
            exit 1
          fi
        working-directory: ./target/release/temp_files
      # delete the temp_files directory
      - name: Delete temp_files
        run: |
          rm -rf ./target/release/temp_files
      # then upload the zip
      - name: Upload Asset
        uses: actions/upload-artifact@main
        with:
          name: ${{ env.EXECUTABLE_NAME }}_macos
          path: ./target/release/${{ env.EXECUTABLE_NAME }}_macos.zip
          compression-level: 0
